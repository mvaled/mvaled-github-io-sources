<!DOCTYPE html>
<html lang="en">
  <head>
        <title>Manuel on Software - Reloaded - Why does creating a list comprehension is faster?</title>
      <meta charset="utf-8" />
      <meta name="generator" content="Pelican" />
      <meta name="viewport" content="width=device-width, initial-scale=1.0">




    <meta name="tags" content="Performance" />
    <meta name="tags" content="Python" />

  </head>

  <body>
      <header>
          <hgroup><h1><a href="/">Manuel on Software - Reloaded</a></h1></hgroup>
          <nav><ul>
                <li><a href="/category/architecture.html" >architecture</a></li>
                <li><a href="/category/blogroll.html" >Blogroll</a></li>
                <li><a href="/category/book-reviews.html" >Book Reviews</a></li>
                <li><a href="/category/misc.html" >misc</a></li>
                <li><a href="/category/openerp.html" >OpenERP</a></li>
                <li><a href="/category/programming.html"  aria-current="page" >Programming</a></li>
                <li><a href="/category/python.html" >Python</a></li>
          </ul></nav>
      </header>
      <main>
  <article>
    <header>
      <h2>
        <a href="/2019/11/18/performance-of-python-list-comprehensions.html" rel="bookmark"
           title="Permalink to Why does creating a list comprehension is faster?">Why does creating a list comprehension is faster?</a></h2>
      
    </header>
    <p>Yesterday, I was removing a list-comprehension as an argument to <tt class="docutils literal">sum</tt>.
This is the diff:</p>
<div class="highlight"><pre><span></span><span class="gd">- sum([p.price for p in self.products])</span>
<span class="gi">+ sum(p.price for p in self.products)</span>
</pre></div>
<p>To show the original programmer my line of though I performed a little
experiment with the following message and code:</p>
<p>List comprehensions as an argument to <em>reduce-like</em> functions are usually less
efficient than using the generation expression itself.  The reason is that
Python creates the list just to discard it afterwards:</p>
<pre class="literal-block">
&gt;&gt;&gt; def fib(n):
...     a, b = 1, 1
...     while a &lt; n:
...         yield a
...         a, b = b, a + b
...

&gt;&gt;&gt; %timeit sum([x for x in fib(100)])
2.61 µs ± 33 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)

&gt;&gt;&gt; %timeit sum(x for x in fib(100))
3.13 µs ± 18.6 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
</pre>
<p>I was surprised to see that the list comprehension was a little bit faster
than the generator expression.  So it seems that for short-enough lists, the
implementation of <tt class="docutils literal">sum</tt> is quite fast.</p>
<p>I had to change the implementation of <cite>fib</cite> to control the amount of items to
show my point:</p>
<pre class="literal-block">
&gt;&gt;&gt; def fib(n):
...     a, b = 1, 1
...     for _ in range(n):
...         yield a
...         a, b = b, a + b
</pre>
<p>An still with 100 items, passing a list is faster:</p>
<pre class="literal-block">
&gt;&gt;&gt; %timeit sum(fib(100))
14.2 µs ± 212 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)

&gt;&gt;&gt; %timeit sum(list(fib(100)))
16.4 µs ± 247 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)

&gt;&gt;&gt; %timeit sum([x for x in fib(100)])
18 µs ± 160 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
</pre>
<p>Of course the differences are too small to draw final conclusions.  And, of
course, as the list grows larger it becomes slower:</p>
<pre class="literal-block">
&gt;&gt;&gt; %timeit sum([x for x in fib(10**5)])
497 ms ± 84.4 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)

&gt;&gt;&gt; %timeit sum(x for x in fib(10**5))
329 ms ± 17.3 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
</pre>
<p>So I think I still prefer the version using the generation expression just to
cover my self from the case where there are too many items to be held in
memory.</p>
<p>(I didn't push the commit, though.)</p>

    <footer>
      <p>Published: <time datetime="2019-11-18T00:00:00+00:00">
        Mo 18 November 2019
      </time></p>
        <address>
          By             <a href="/author/manuel-vazquez-acosta.html">Manuel Vázquez Acosta</a>
        </address>
        <p>
          Category: <a href="/category/programming.html">Programming</a>
        </p>
        <p>
          Tags:
            <a href="/tag/performance.html">Performance</a>
            <a href="/tag/python.html">Python</a>
        </p>
    </footer>
  </article>
      </main>
      <footer>
          <address>
            Proudly powered by <a rel="nofollow" href="https://getpelican.com/">Pelican</a>,
            which takes great advantage of <a rel="nofollow" href="https://www.python.org/">Python</a>.
          </address>
      </footer>
  </body>
</html>