<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sofretería</title>
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Merriweather:wght@400;700&family=Roboto+Mono&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="/theme/static/style.css">
</head>
<body>
    <header>
        <h1><a href="/">Sofretería</a></h1>
    </header>
    <main>
<article>
    <header>
        <h2>Composing iterator-returning&nbsp;functions</h2>
        <p class="meta">2018-08-01 &bull; Manuel Vázquez Acosta</p>
    </header>
    <p>A few days ago I was reviewing a piece of Python code.  I was looking for a
bug, but in the process I found a very interesting&nbsp;function.</p>
<p>The system allows the user to &#8220;extend&#8221; the structure of Products by providing
more attributes which can be used later on when creating Sale (or Purchase)
Orders.  The Product object is like a class defining the structure, and the
items in Orders are the instances of such&nbsp;classes.</p>
<p>When trying to export a full catalog, each attribute implies a new row in the
spreadsheet file.  To avoid too much coupling, this process was modeled by a
kind of seeded generation of every possible row.  The algorithm started with a
seed instance of a product without any attribute, and then it generated every
possible attribute-complete instance by <em>composing</em> several functions that
took a instance and returned a iterator of instances.  Each function deals
with a specific type of attribute, and simply copies those attributes in the
instances being&nbsp;generated.</p>
<p>The function doing the generation of all possible instance was more or less
like&nbsp;this:</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">iter_product</span><span class="p">(</span><span class="n">initial</span><span class="p">,</span> <span class="o">*</span><span class="n">funcs</span><span class="p">):</span>
   <span class="k">if</span> <span class="ow">not</span> <span class="n">funcs</span><span class="p">:</span>
      <span class="k">yield</span> <span class="n">initial</span>
   <span class="k">else</span><span class="p">:</span>
      <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">fs</span> <span class="o">=</span> <span class="n">funcs</span>
      <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">f</span><span class="p">(</span><span class="n">initial</span><span class="p">):</span>
         <span class="k">yield from</span> <span class="n">iter_product</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">fs</span><span class="p">)</span>
</pre></div>
<p>That definition was <span class="caps">OK</span>, but I wondered if I could build just the <em>composition</em>
of several functions returning iterators, so that I can reuse it with several
initial&nbsp;objects.</p>
<div class="section" id="a-little-incursion-in-haskell">
<h2>A little incursion in&nbsp;Haskell</h2>
<p>In order to test my Haskell, I did first a Haskell version.  I started by
trying to create a <em>composition</em> operator much like the <tt class="docutils literal">(.)</tt> operator,
which has&nbsp;type:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="o">.</span><span class="p">)</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">c</span>
</pre></div>
<p>The type of our composition of iterator-returning functions would&nbsp;be:</p>
<div class="highlight"><pre><span></span><span class="kr">infixr</span><span class="w"> </span><span class="mi">9</span><span class="w"> </span><span class="o">&gt;&gt;.</span>
<span class="p">(</span><span class="o">&gt;&gt;.</span><span class="p">)</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">c</span><span class="p">])</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">b</span><span class="p">])</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">c</span><span class="p">]</span>
</pre></div>
<p>The choice of <tt class="docutils literal"><span class="pre">(&gt;&gt;.)</span></tt> as the operator will become (I hope) evident.  The
most straightforward implementation and easy to understand is using the
list-comprehension&nbsp;syntax:</p>
<div class="highlight"><pre><span></span><span class="nf">g</span><span class="w"> </span><span class="o">&gt;&gt;.</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="nf">\</span><span class="n">x</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">z</span><span class="o">|</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="n">y</span><span class="p">]</span>
</pre></div>
<p>Can we generalize this?  Yes! The list is an instance of a <a class="reference external" href="http://book.realworldhaskell.org/read/monads.html">Monad</a>, defined&nbsp;as:</p>
<div class="highlight"><pre><span></span><span class="kr">instance</span><span class="w"> </span><span class="kt">Monad</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="kr">where</span>
<span class="w">    </span><span class="n">return</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="p">]</span>
<span class="w">    </span><span class="n">m</span><span class="w"> </span><span class="o">&gt;&gt;=</span><span class="w"> </span><span class="n">f</span><span class="w">  </span><span class="ow">=</span><span class="w"> </span><span class="n">concat</span><span class="w"> </span><span class="p">(</span><span class="n">map</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">m</span><span class="p">)</span>
</pre></div>
<p>And list comprehensions can be easily rewritten using the <tt class="docutils literal">do</tt> notation:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="o">&gt;&gt;.</span><span class="p">)</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Monad</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">c</span>
<span class="nf">g</span><span class="w"> </span><span class="o">&gt;&gt;.</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="nf">\</span><span class="n">x</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kr">do</span><span class="p">{</span><span class="n">y</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="n">y</span><span class="p">;</span><span class="w"> </span><span class="n">return</span><span class="w"> </span><span class="n">z</span><span class="p">}</span>
</pre></div>
<p>The monadic <tt class="docutils literal">&gt;&gt;=</tt> operator is usually called the <em>bind</em>.  It&#8217;s type&nbsp;is</p>
<pre class="literal-block">
Monad m =&gt; m a -&gt; (a -&gt; m b) -&gt; m b
</pre>
<p>So, I think there&#8217;s a compact way to write our <tt class="docutils literal">&gt;&gt;.</tt> operator.  And, now you
may start to see why I chose <tt class="docutils literal">&gt;&gt;.</tt>.</p>
<p>The do notation is just syntax-sugar over using <tt class="docutils literal">&gt;&gt;=</tt> (or its brother
<tt class="docutils literal">&gt;&gt;</tt>).  The rules are given <a class="reference external" href="http://book.realworldhaskell.org/read/monads.html#monads.do">here</a>.  So let&#8217;s transform our implementation.
We start we our current&nbsp;definition:</p>
<pre class="literal-block">
\x -&gt; do {y &lt;- f x; z &lt;- g y; return z}
</pre>
<p>And rewrite the <tt class="docutils literal">do</tt> two times until there are no&nbsp;more:</p>
<pre class="literal-block">
\x -&gt; let s1 y = do {z &lt;- g y; return z} in f x &gt;&gt;= s1

\x -&gt; let s1 y = (let s2 z = return z in g y &gt;&gt;= s2) in f x &gt;&gt;= s1
</pre>
<p>Now, we can recall the <a class="reference external" href="https://wiki.haskell.org/Eta_conversion">eta-conversion rule</a> and see that <tt class="docutils literal">s2 = return</tt>,&nbsp;so:</p>
<pre class="literal-block">
\x -&gt; let s1 y = (g y &gt;&gt;= return) in f x &gt;&gt;= s1
</pre>
<p>Now we can use the monadic &#8220;law&#8221; that states the <tt class="docutils literal">m &gt;&gt;= return</tt> must be
equivalent to <tt class="docutils literal">m</tt>:</p>
<pre class="literal-block">
\x -&gt; let s1 y = g y in f x &gt;&gt;= s1
</pre>
<p>And, once more, the eta-conversion help us to remove the <cite>let</cite>, because
<tt class="docutils literal"><span class="pre">s1&nbsp;==</span> g</tt>.  Thus we&nbsp;get:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="o">&gt;&gt;.</span><span class="p">)</span><span class="w">  </span><span class="ow">::</span><span class="w"> </span><span class="kt">Monad</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">c</span>
<span class="nf">g</span><span class="w"> </span><span class="o">&gt;&gt;.</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="nf">\</span><span class="n">x</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&gt;&gt;=</span><span class="w"> </span><span class="n">g</span>
</pre></div>
<p>This is as good as I was able to get.  Since we&#8217;re using <tt class="docutils literal">&gt;&gt;=</tt>, I think this
is the best we can get (i.e. we can&#8217;t generalize to <a class="reference external" href="https://wiki.haskell.org/Applicative_functor">Applicative</a>).</p>
</div>
<div class="section" id="chaining-several-iterator-returning-functions">
<h2>Chaining several iterator-returning&nbsp;functions</h2>
<p>Now, I can define a <tt class="docutils literal">chain</tt> function.  It takes a list of several
<tt class="docutils literal"><span class="pre">a&nbsp;-&gt;&nbsp;m&nbsp;a</span></tt> functions and compose them together (from right to left, as&nbsp;expected):</p>
<div class="highlight"><pre><span></span><span class="nf">chain</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Monad</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">a</span>
</pre></div>
<p>My first attempt&nbsp;was:</p>
<div class="highlight"><pre><span></span><span class="nf">chain</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Monad</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">a</span>
<span class="nf">chain</span><span class="w"> </span><span class="kt">[]</span><span class="w">  </span><span class="ow">=</span><span class="w"> </span><span class="n">return</span>
<span class="nf">chain</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="kt">:</span><span class="n">fs</span><span class="p">)</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">&gt;&gt;.</span><span class="w"> </span><span class="p">(</span><span class="n">chain</span><span class="w"> </span><span class="n">fs</span><span class="p">)</span>
</pre></div>
<p>But, then I realized that&#8217;s a&nbsp;fold:</p>
<div class="highlight"><pre><span></span><span class="nf">chain</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">(</span><span class="kt">Foldable</span><span class="w"> </span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="kt">Monad</span><span class="w"> </span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="ow">=&gt;</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">a</span>
<span class="nf">chain</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">foldr</span><span class="w"> </span><span class="p">(</span><span class="o">&gt;&gt;.</span><span class="p">)</span><span class="w"> </span><span class="n">return</span>
</pre></div>
<p>And that completes our incursion in&nbsp;Haskell.</p>
</div>
<div class="section" id="doing-the-same-in-python">
<h2>Doing the same in&nbsp;Python</h2>
<p>Going from this Haskell definition of <tt class="docutils literal">chain</tt> to Python is quite easy.  But
we&#8217;re not going to work with any possible monad, just lists (iterators,&nbsp;actually).</p>
<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">reduce</span>

<span class="k">def</span> <span class="nf">iter_compose</span><span class="p">(</span><span class="o">*</span><span class="n">fs</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">fs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="c1"># optimize the &#39;lambda x: [x]&#39; for the *usual* case of 2-args.</span>
        <span class="k">return</span> <span class="n">_compose</span><span class="p">(</span><span class="o">*</span><span class="n">fs</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">reduce</span><span class="p">(</span><span class="n">_compose</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">[</span><span class="n">x</span><span class="p">])</span>

<span class="k">def</span> <span class="nf">_compose</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
   <span class="k">return</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">z</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="n">g</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
</pre></div>
<p>We have included <tt class="docutils literal">~xoutil.fp.iterators.iter_compose</tt> in <a class="reference external" href="https://github.com/merchise/xoutil">xoutil</a> 1.9.6
and&nbsp;2.0.6.</p>
</div>

</article>
    </main>
    <footer>
        <p>&copy; 2016-2025 Manuel Vázquez Acosta</p>
    </footer>
</body>
</html>